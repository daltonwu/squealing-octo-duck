2015-09-10 Thurs
Aim: Time to C what we can do.

Do Now: What command line programs would do the following?
	(always assume you are starting at your home directory)
	
	1) Move foo.java from Desktop/ to Documents/
	2) Remove all .class files
	3) Connect to lisa.stuy.edu from someplace else
	4) Figure out what gcc does
	5) Copy woohoo.c from your home directory to a /code/ directory on homer (assume you are not working on homer itself)



2015-09-11 Fri
Aim: C what I did there?

Do now:

	From yesterday:
		4) Figure out what gcc does
		5) Copy woohoo.c from your home directory to a /code/ directory on homer (assume you are not working on homer itself)
		
	Today:
		List the Java primitive variable types
		* byte
		* short
		* int
		* long
		* float
		* double
		* boolean
		* char
		
	Last Class Today!
	
		Every day, 1 student will be chosen at random to provide a recap of the previous day's class.
		
		That evening, the same person will be responsible for posting the notes to the class Piazza page. Make sure to tag the note as "last class today".
		
			Title the note LCT <MM/DD WEEKDAY>
			For example: LCT 09/10 Thursday
			
			Also include at the end of the note a link to an interesting piece of tech/science news.



2015-09-16 Wed
Aim: Variables are the spice of life.

Do Now: What is the smallest variable type that could be used to store the following values (using standard sizes)?

	1) 5				byte
	2) -30,000			short
	3) 255				short
	4) 5,000,000,000	float
	
C Primitive Variable Types
	
	All C primitives are numeric.
	
	The only difference is floating point vs. integer and size of variable.
	
	Size can be platform dependent.
		sizeof(<TYPE>) can be used to find the size in bytes.
		
		sizeof(int)
		
	Types	Standard Size (bytes)
	int			4
	short		2
	long		8
	float		4
	double		8
	char		1
	
	All boolean values are numbers:
		0  == false
		!0 == true
		
		YOU WILL ALL MAKE THIS MISTAKE:
			if(x = 6) {…}



2015-09-17 Thurs
Aim: Always read the fine print.

Do Now: Open up your editor of choice (Emacs), write a basic "Hello, world!" program in Java.

Data Types and Variables
	
	Character literals are single characters inside ''.
		e.g., 'a', '*'
	
	String literals exist, even though there is no string data type.
		e.g., "hello", "you smell"
	
	Any variable type can be decalred an "unsigned" variable. This signifies the variable will never be negative.
		The lower bound of any unsigned variable is 0.
		The upper bound will be greater than the signed version.
		
		e.g.	unsigned char x;
				0 <= x <= 255



2015-09-18 Fri
SotD: "Superstitious" — Stevie Wonder
Aim: A vast array of possibilities.

Do Now: How do you declare/use arrays in Java?

Mentioned:
$ echo $PATH
$ which emacs

plus C funsies



2015-09-22 Tues
SotD: "Hunger Strike" — Temple of the Dog
Aim: What's the point of it all?

Memory management
	
	Memory allocation happens either at compile time or at run time (dynamic).
	
	Compiler Allocated Memory (Stack)
		Packaged with the binary of the program
		
		There is no standard default value
		
		Variables and arrays qare allocated here
			e.g., float a		int b[5]
		
		Arrays
			Are not dynamic
			
			Must have a fixed size
			
			There is no length function
			
			There is no boundary checking
	
	Heap Allocated Memory (Java keyword new)
	

2015-09-25 Fri
SotD: "Here Comes the Hotstepper" — Ini Kamoze
Aim: Ok, now we're really going to get to the point.

int fred;
fred is a placeholder pointing to a value in memory (an address in memory containing some information)

Pointers — the fun really starts
	
	Variables designed to store memory addresses (think references in Java)
	
	& is used to get the address of a variable
	
	* is used to declare a variable as a pointer type
		e.g., int *p, double *q, char *r …
	
	* is also used as the de-reference operator
		It accesses the value at the memory location stored in a pointer



2015-09-28 Mon
SotD: "Lump" — The Presidents of the United States of America
Aim: Ok, now we're really going to get to the point.

Do Now:
	1) Declare int, double, and char variables.
	2) Declare int, double, and char pointers.
	3) Initialize each pointer to the address of the corresponding variable.
	4) Print out the pointer's value for each (as an unsigned long).
	5) Add 1 to each pointer.
	6) Print out the pointers again.
	What happened?



2015-09-29 Tues
SotD: "In the Meantime" — Spacehog
Aim: Time to stop stringing you along.

float fray[5]; // f-array, or f-ray
float *fp = fray;

C strings (ctrings)
	
	Strings are character arrays that end with a null character (either '' or 0 f '\0').
	The terminating null character is a convention. String functions will not work correctly without it.
	The following are valid ways to declare strings:
		
		char s[256]
			Normal array declaration, allocates 256 bytes, nothing is set automatically
		
		char s[256] = "Imagine";
			Allocates 256 bytes, puts "Imagine" in the first 7 bytes and adds a null at the 8th byte
		
		char s[] = "Tuesday";
			Allocates 8 bytes, puts "Tuesday" in the first 7 bytes and adds a null at the 8th byte.
		
		char *s = "Mankind";
			Allocates 8 bytes, puts "Mankind" in the first 7 bytes and adds a null at the 8th byte. s is a pointer variable instead of an array.
	
	You can only assign strings with = at declaration.
		char s[] = "zero";	//ok
		s = "seven";		// not ok



2015-09-30 Wed
SotD: "One Headlight" — The Wallflowers
Aim: How to write functioning code

Do Now: Write a C program that does the following:
	1) Creates a string and sets it to some value.
	2) Finds the length of the string and then prints it (code in main function)



2015-10-01 Thurs
SotD: "Tom Sawyer" — Rush
Aim: How to write functioning code

Functions: A brief interlude
	
	All C functions are "pass by value"
		A parameter is a copy of the variable passed into the function.
		The original variable is not touched.
	
	function headers
		<return type> <name> (<parameters>)
	
	You must declare a function before you use it.
	This can be done in a few ways:
		
		1) Write the entire function at the top of your code, making sure to keep the order correct.
		
		2) Write the function headers at the top of your code, and then provide the full definition later.
		
		3) Put all the function headers in a separate file (ending in .h). Then include that file in your .c file and provice the efinitions there.

Back to Ctrings
	
	string.h
		C library that includes useful string functions.
		
		All the functions assume that the parameter strings are always null-terminated.
		
		int strlen(char*s)
			Returns the number of characters from the start of s up to but not including the termianting null
		
		int strcmp(char *s1, char *s2)
			Returns 0 if s1 and s2 are indentical up to the terminating null.
			
			Returns a positive number of s1 is lexicographically greater than s2
		
		char * strcpy(char *dest, char *source)
			Copies all the chars up to and including the terminating null from source into dest
			
			Returns dest
		
		char * strcat(char *s1, char *s2)
			Appends all the characters up to and including the terminating null in s2 to the end of s1
			
			Returns s1
		
		Many string functions have a "strn" version, these take an extra parameter that sets a limit to the number of bytes you will look at in a string.
			
			strncat(char *s1, char *s2, int n)
				Appends at most n chars from s2 into s1.
				
				It will stop if it hits a terminating null in s2 before n bytes.



2015-10-02 Fri



2015-10-05 Mon
SotD: "Thunderstruck" — AC/DC



2015-10-06 Tues
SotD: "Fake Plastic Trees" — Radiohead
Aim: Make it so



2015-10-07 Wed
SotD: "Rearviewmirror" — Pearl Jam
Aim: Make it so

Separate compilation
	
	You can combine multiple C files into a C program by including them all in one gcc command.
		e.g.:
			gcc test.c string.c foo.c woohoo.c
	
	You cannot have duplicate function or global variable names across these files. This includes the main function.
	
	gcc -c
		Will compile a .c file into a .o file (compiled code file, not a fully functional program). Do this to compile a .c file that does not contain a main function.
	
	gcc can link .o files together with .c files.


2015-10-08 Thurs
SoTD: "Breaking the Girl" — Red Hot Chili Peppers
Aim: If you can't (al)locate your memory then … I forget

Dynamic memory allocation
	
	malloc(int x)
		Allocates x bytes of memory (from the heap)
		
		Returns the address at the beginning of the allocation
		
		Returns a void *, always typecast to the correct pointer type
	
	calloc(int n, int x)
		Allocates n * x bytes of memory
		
		Ensures that each bit is set to 0
		
		Works like malloc in all other ways
	
	realloc(void *p, int x)
		Changes the amount of memory allocated to a given block.
		
		p must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer
		
		If x is smaller than the original size of the alocation, the extra bytes will be released



2015-10-09 Fri
SotD: "Papa's Got a Brand New Bag" — James Brown
Aim: Always structure your code well.

Dynamic Memory Allocation
	
	Normal memory allocation happens on the stack.
	
	Stack memory gets released as functions pop off.
	
	Dynamic memory is located on the heap. It presists even after the function that created it pops off the stack.
	
	You must manually release dynamically allocated memory from the heap.
	
	void free(void *ptr)
		Releases dynamically allocated memory.
		
		Takes one parameter, a pointer to the beginning of a dynamically allocated block of memory.
		
		Every call to malloc/calloc should have a corresponding call to free.
		
		int *p;
		p = (int *)malloc(20);
		free(p);
	
typedef
	Provide a new name for an existing datatype.
	
	typedef <real type> <new name>;
	
	e.g.:
		typedef unsigned int size_t;
		size_t x = 139; // x is really an unsigned int

struct
	A collection of values in a single datatype
	
	struct {
		int a;
		char x;
	} s;



2015-10-12 Mon



2015-10-13 Tues
SoTD: "Low Rider" — War
Aim: Zelda's in trouble, get Link!

Do Now: What's wrong with this function?
		(Assume that node has been declared correctly)

node *insert_front(node *n, int i) {
	node new;
	
	new.i = i;
	new.next = n;
	
	return &new;
}



2015-10-14 Wed
2015-10-15 Thurs
2015-10-16 Fri

2015-10-19 Mon
2015-10-20 Tues
SoTD: "Wheels" ― Cake
Aim: File this under useful information.

Do Now: What are the different kinds of file permissions?

File permissions
	
	3 kinds of permissions
		read, write, execute
	



2015-10-21 Wed

Note: Don't compile .h files!

SoTD: "Everything" — MrNorth
Aim: Opening up a whole new world of possibilities.

chmod
chown
chgrp

File Table
	
	A list of all files used by a program while it is running.
	
	Contains basic information like the file's location and size.
	
	The file table has a limited size, which is a power of 2 and commonly 256. getdtablesize() will return this value.
	
	Each file is given an integer index, starting at 0. This is referred to as the file descriptor.
	
	There are 3 files always open in the table:
		0	STDIN_FILENO	stdin
		1	STDOUT_FILENO	stdout
		2	STDERR_FILENO	stderr
	
	open	<fcntl.h>
		Add a file to the file table and returns its file descriptor.
		
		If open fails, -1 is returned. Extra error information can be found in errno.
			
			errno is an int variable that can be found in <errno.h>
			Using strerr (in <string.h) on errno returns a string description of the error
		
		open(<PATH>, <FLAGS>, <MODE>)
		
		mode
			Only used when creating a file.
			Set the new file's permissions using a 3-digit octal num.
			
			Octal nums have a leading 0
				0644, 0777, …
		
		flags
			Determine what you plan to do with the file.
			
			Use the following constants:
				O_RDONLY
				O_WRONLY
				O_RDWR
				O_APPEND
				O_TRUNC
				O_CREAT
				O_EXCL	(when combined with O_CREAT, returns error if file exists)
		
		
		
					~a brief interlude~
		
		
		
		bitwise operators
			&: bitwise and
			|: bitwise or
			~: bitwise not
			^: bitwise xor
			
			logical operators work on each bit of a value
			
			char c = 13; // 00001101
			char x = ~c; // 11110010
			
			
			
					~back to open()~
		
		
		
		flags
			Each flag is a number. To combine flags, use bitwise or:
			
			O_WRONLY = 1			00000001
			O_APPEND = 8			00001000
			O_WRONLY | O_APPEND		00001001


close — <unistd.h>
	Remove a file from the file table.
	
	Returns 0 if successful. Returns -1 and sets errno if unsuccessful.
	
	close(<FILE DESCRIPTOR>);

read — <unistd.h>
	Read in data from a file
	
	read(<FILE DESCRIPTOR>, <BUFFER>, <AMOUNT>)
	read(fd, buff, n)
	
	Read n bytes from the fd's file and put that data into buff
	
	Returns the number of bytes actually read. Returns -1 and sets errno if unsuccessful.
	
	BUFFER must be a pointer.



2015-10-22 Thurs
2015-10-23 Fri

2015-10-26 Mon
SoTD: "Crazy" — Gnarls Barkley
Aim: Seek and ye shall find

umask — <sys/stat.h>
	
	Set the file creation permission mask
	
	By default, created files are not given the exact permissions provided in the mode argument to open.
	
	A mask is applied that automatically shuts off certain permissions.
	
	Umask is applied by using bitwise negation on the mask, then bitwise anding it to the mode
		new_permissions = ~mask & mode
	
	The default mask is 022, which shuts off write permissions for group and other.
	
	umask(<MASK>);
		You can define the umask using a 3-digit octal #
		umask(0000);

lseek — <unistd.h>
	
	Set the current position in an open file
	
	lseek(<FILE DESCRIPTOR>, <OFFSET>, <WHENCE>)
	
	offset
		Number of bytes to move the position by.
		Can be negative.
	
	whence
		Where to measure the offset from
		
		SEEK_SET
			offset is evaluated from the beginning of the file
		
		SEEK_CUR
			offset is relative to the current position in the file
		
		SEEK_END
			offset is evaluated from the end of the file
	
	returns the number of bytes the current position is from the beginning of the file, or -1 (errno)



2015-10-27 Tues



2015-10-28 Wed
SoTD: "For What It's Worth" — Buffalo Springfield
Aim: I need information, stat!
Do Now:
	1) Make a directory
	2) Put a few files in that directory and maybe even a directory or two

stat — <sys/stat.h>
	
	Get information about a file (metadata)
	
	stat(<PATH>, <STAT BUFFER>)
		
		struct stat sb;
		stat("foo", &sb);
	
	STAT BUFFER
		
		Must be a pointer to a struct stat
		
		All the file information gets put into the stat buffer.
		
		Some of the fields in struct stat:
			st_size
				file size in bytes
			
			st_uid, st_gid
				user id, group id
			
			st_mode
				file permissions
			
			st_atime, st_mtime
				last access, last modification
				
				These are struct time_t variables. We can use functions in time.h to make sense of them
				
				ctime(<time_t *>)
					returns the time as a string
				time(<time_t *>)
					sets the parameter to the current time



2015-10-29 Thurs
SoTD: "In the Waiting Line" — Zero 7
Aim: Where do compsci priests live? — In directory!

Directories
	
	A *nix directory is a file containing the names of the files within the directory along with basic information like filetype.
	
	Moving files into/out of a directory means changing the directory file, not actually moving any data.

opendir — <dirent.h>
	
	Open a directory file
	
	This will not change the cwd, it only allows your program to read the contents of the directory file
	
	opendir(<PATH>);
	
	Returns a pointer to a directory stream (DIR *)

closedir — <dirent.h>
	
	Closes the directory stream and frees the pointer associated with it.
	
	closedir(<DIRECTORY STREAM>)

readdir — <dirent.h>
	
	readdir(<DIRECTORY STREAM>)
	
	Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.
	
	struct dirent — <sys/types.h>
		
		Directory struct that contains the information stored in a directory file.
		
		Some of the data members
			
			d_name: Name of a file
			d_type: Filetype as an int
	
	example:
		DIR *d;
		d = opendir("somedir");
		
		struct dirent *entry;
		entry = readdir(d);

rewinddir — <dirent.h>
	
	Resets the directory stream to the beginning
	
	rewinddir(<DIRECTORY STREAM>)



2015-10-30 Fri
SoTD: "War Pigs" — Black Sabbath
Aim: Puttin' in the puts.

Command-Line Arguments
	
	int main(int argc, char *argv[])
	
	program name is considered the first command-line argument
	
	argc
		number of command-line arguments
	
	argv
		array of command-line arguments
	
scanf — <stdio.h>
	
	scanf(<FORMAT STRING>, <VAR 1>, <VAR 2>, …)
	
	Reads in data from stdin using the format string to determine types.
	
	Puts the data in each variable.
	
	Variables must be pointers
	
	int x; float f; double d;
	scanf("%d %f %lf", &x, &f, &d);

fgets — <stdio.h>
	 
	 sscanf



2015-11-02 Mon
2015-11-03 Tues
2015-11-04 Wed
SoTD: "Shine" — Collective Soul
Aim: Are your processes running? — Then you should go out and catch them!
Do Now: Run the command ps in a terminal. What do you see?

Processes
	Every running program is a process. A process can create subprocesses, but these are no different from regular processes.
	
	A processor can handle 1 process per cycle (per core).
	"Multitasking" appears to happen because the processor switches between all the active processes quickly.
	
	pid
		Every process has a unique identifier called the pid.
		
		pid 1 is the init process
		
		Each entry in the /proc directory is a current pid
	
	getpid() — <unistd.h>
		returns the current process's pid
	
	getppid() — <unistd.h>
		returns parent process's pid
	
	fork() — <unistd.h>
		Creates a separate process based on the current one. The new process is called the child. The original is called the parent.
		
		The child process is a duplicate of the parent process. All parts of the parent process are copied, including stack and heap memory, and the file table.
		
			A quick note on threads: a thread is a separate executable entity similar to a child process, except a thread is not a standalone process.
			It does not have its own memory space, instead it shares its parent's memory.
		
		Returns 0 to the child and the child's pid to the parent or -1 (errno).
		
		If a parent process ends before the child, the child's new parent pid is 1
	
	wait — <unistd.h>
		
		Stops a parent process from running until any child has provided status information to the parent (usualy the child has exited).
		
		Returns the pid of the child that exited, or -1 (errno).



2015-11-05 Thurs
SoTD: "Us and Them" — Pink Floyd
Aim: Go fork off (another process)



2015-11-06 Fri



2015-11-09 Mon
SoTD: "Losing My Religion" — REM
Aim: Time to bring out the executioner.



2015-11-10 Tues
SoTD: "Burden in my Hand" — Soundgarden
Aim: Invasion of the Process Snatchers.

waitpid — <unistd.h>
	
	Waits for a specific child
	
	waitpid(pid, status, options)
		pid
			The pid of the specific child to look for
			If -1, will wait for any child.
		
		options
			Can set other behaivior for wait, if 0, will work normally.

The exec family — <unistd.h>
	There are a number of C functions that can be used to run other programs from within our own programs.
	
	Replaces the current process with the new program, any code after a call to an exec function will be ignored.
	
	execl
		execl(<PATH>, <COMMAND>, <ARGS>, NULL)
		
		PATH
			The path to the program (ex: "/bin/ls")
		
		COMMAND
			The name of the program (ex: "ls")
		
		ARGS
			Each command-line argument you wish to give the program (ex "-a", "-l")
			
			The last argument must be NULL
		
		example
			execl("/bin/ls", "ls", "-a", "-l", NULL);
	
	execlp
		execlp(<PATH>, <COMMAND>, <ARGS>, NULL)
		
		Works like execl, except it uses the PATH environment variable for commands, so you can use "ls" as the PATH instead of "/bin/ls"
		
		execlp("ls", "ls", "-a", "-l", NULL)
	
	execvp
		execvp(<PATH>, <ARGUMENT ARRAY>)
		
		ARGUMENT ARRAY
			Array of strings, with element 0 must be the name of the program to be executed and the last element must be NULL.
		
		Like execlp, the PATH argument will take the PATH environment variable into account.



2015-11-11 Wed
2015-11-12 Thurs
2015-11-13 Fri
SoTD: "Sell Out" — Reel Big Fish
Aim: Let's take this to delimit!

strsep — <string.h>
	
	Used for parsing a string with a common delimiter
	
	strsep(<SOURCE>, <DELIMITER>)
	
	Locates the first occurrence of the delimiter in a string and replaces that character with NULL
	
	Returns the beginning of the original string
	sets the source string to the string starting at 1 index past the location of the new NULL
	
	Since the source variable's value is changed, it must be a pointer to a string.
	
	char line[100] = "wow-this-is-cool";
	char *s1 = line;
	
	strsep( &s1, "-" )
		replace the - after wow with NULL
		returns "wow"
		sets s1 to "this-is-cool"



2015-11-16 Mon
SoTD: "Gimmie Shelter" — The Rolling Stones
Aim: Redirection, how does it … SQUIRREL

File Redirection
	
	Changing the usual input/output behavior of a program
	
	Command-line redirection
		>
			Redirects stdout to a file
			
			Overwrite the contents of the file
			
			<COMMAND> > <FILE>
			
			ls > file_list
		>>
			Redirects stdout to a file
			
			Appends instead of overwrites
		2>
			Redirects stderr to a file
			
			Overwrites the file (2>> appends)
		
		&>
			Redirect stdout and stderr
		
		<
			Redirects stdin from a file
		
		| (pipe)
			Redirect stdout from one command to stdin of the next
			
			ls | wc
	
	Redirection in C programs
		
		dup2 — <unistd.h>
			
			Redirect one file descriptor to another
			
			dup2(fd1, fd2)
				Redirects fd2 to fd1
				
				You will lose any reference to the original fd2, that file is closed.
		
		dup — <unistd.h>
			
			Duplicates an existing entry in the file table.
			
			Returns a new file descriptor for the duplicate entry.
			
			dup(fd)
				returns the new file descriptor
    
    chdir(<PATH>);



2015-11-17 Tues
2015-11-18 Wed
2015-11-19 Thurs
2015-11-20 Fri

2015-11-23 Mon
2015-11-24 Tues
2015-11-25 Wed
2015-11-26 Thurs
2015-11-27 Fri

2015-11-30 Mon
SoTD: "Billie Jean" — Michael Jackson
Aim: Sending mixed signals

Signals
	
	Limited way of sending information to a process.
	
	kill
		Command-line utility to send a signal to a process
		
		$ kill <PID>
			Sends signal 15 (SIGTERM) to PID
			
			$ kill -<SIGNAL> <PID>
				sends SIGNAL to PID
	killall [-<SIGNAL>] <PROCESS>
		
		Sends SIGTERM (or SIGNAL if provided) to all processes with PROCESS as the name

Signal handling in C programs <signal.h>
	
	kill
		Send a signal to a process in a C program
		
		kill(<PID>, <SIGNAL>)
		
		Returns 0 on success or -1 (errno) on failure
	
	sighandler
		To work with signals in a C program you must create a signal-handling function.
		
		Some signals (like SIGKILL) cannot be caught.
		
		//[CODE]
		
		#include <stdio.h>
		#include <signal.h>
		
		/*
			Static functions must be written in the file where they are used.
			sighandler() must be static because it listens for signals.
		*/
		
		static void sighandler(int signo) {
			if(signo == SIGINT) {
				printf("Interrupted … How rude!\n");
				exit(0);
			}
			else if(signo == SIGSEGV) {
				printf("Nothing to see here …\n");
			}
		}
		
		int main() {
			signal(SIGINT, sighandler);
			signal(SIGSEGV, sighandler);
			int i = 0;
			while(1) {
				printf("G'day, mate!\t%d\t%d\n", i++, getpid());
				sleep(1);
			}
		}



2015-12-01 Tues
SoTD: "Say It Ain't So" — Weezer
Aim: You want the signal? You can't handle the signal!

Signal handling in C programs <signal.h>
	
	sighandler
		To work with signals in a C program you must create a signal handling function.
		
		Some signals (like SIGKILL) cannot be caught.
		
		static void sighandler(int signo)
		
		Must be static, must be void, must take a single int parameter.
		
		static
			The function can only be called from a within the file it is defined.
	
	signal
		After you create the function, you attach the signals to it using the signal function:
			
			signal(SIGNUMBER, sighandler)



2015-12-02 Wed
NOTE: Registering for graphics
SoTD: "Imagine" — John Lennon
Aim: Sharing is caring!

Do Now:
	Write a simple C program that creates a child process and have the parent
	wait for the child to exit.
	
	Create a primitive variable in the parent before forking, then modify that
	variable in the child and print it out in both the child and the parent.

Shared Memory — <sys/shm.h>, <sys/ipc.h>, <sys/types.h>
	A segment of heap memory that can be accessed by multiple processes.
	
	Shared memory is accessed via some key that is known by any process that
	needs to access it.
	
	Shared memory does not get released when a program exits.
	
	5 shared-memory operations:
		1.	Create the segment (happens just once)
		2.	Access the segment (once each process)
		3.	Attach the segment to a variable (once each process)
		4.	Detach the segment from the variable (once each process)
		5.	Remove the segment (happens just once)

	shmget
		Creates or accesses a shared memory segment.
		
		Returns a shared memory descriptor (similar to file descriptor),
		or -1 if it fails.
		
		#include <sys/ipc.h>
		#include <sys/shm.h>
		
		int shmget(key_t key, size_t size, int shmflag);
		
			key
				Unique integer identifier for the shared memory segment.
			
			size
				How much memory to request.
			
			flags
				Include permissions for the segment.
				
				Combine with bitwise OR
				
				IPC_CREAT
					Creates the segment.
					If segment is new, will zero all bits.
				
				IPC_EXCL
					Fail if the segment already exists and IPC_CREAT is on.
			
			Example:
				int sd;
				sd = shmget(24601, 1024, 0644 | IPC_CREAT);
	
	shmat
		Attaches a shared memory segment to a variable.
		
		Returns a pointer to the segment or -1 (errno).
		
		#include <sys/types.h>
		#include <sys/shm.h>
		
		void *shmat(int shmid, const void *shmaddr, int shmflag);
		
			shmid
				Descriptor (return value of shmget)
			
			shmaddr
				Address
			
			shmflag
				


2015-12-03 Thurs
2015-12-04 Fri
SoTD: "Plush" — Stone Temple Pilots
Aim: Memes

Shared Memory!
	ftok()
		Generates a key useful for IPC functions.
		
		#include <sys/types.h>
		#include <sys/ipc.h>
		
		key_t ftok(const char *pathname, int proj_id);
			pathname
				A path to some file, which must be accessible by the program.
			
			proj_id
				An int.
			
			The key generated by will be the same if path and x are the same for
			separate calls.
		
		sd = shmget(ftok("dir/file", 12), 1024,
					IPC_CREAT | 0664);
	
	shmdt()
		Detaches a variable from a shared memory segment.
		
		Returns 0 upon success and -1 upon failure.
		
		shmdt(pointer)
			pointer
				The address used to access the segment.
	
	shmctl()
		Performs operations on the shared memory segment.
		
		Each shared memory segment has metadata that can be stored in a struct
		(struct shmid_ds)
		
		Some of that data stored: last access, size, pid of creator, pid of
		last modification.
		
		shmctl(descriptor, command, buffer)
			descriptor
				Return value of shmget
			
			commands:
				IPC_STAT: populates the buffer (struct shmid_ds)
					with information
				
				IPC_SET: set some of the information for the segment
					to the information in buffer
				
				IPC_RMID: remove a shared memory segment



2015-12-07 Mon
SoTD: "The General" — Dispatch
Aim: How do we flag a resource?

Semaphores (created by Edsgar Dijkstra)
	
	IPC construct used to control access to a shared resource (like a file or
	shared memory).
	
	Essentially, a semaphore is a counter that represents how many processes
	can access a resource at any given time.
		
		If a semaphore has a value of 3, then it can have 3 active "users".
		
		If a semaphore has a value of 0, then it is unavailable.
	
	Most semaphore operations are "atomic", meaning they will not be split up
	into multiple processor instructions.
	
	Semaphore operations:
		
		Create a semaphore
		Set an intial value
		Up(S) / V(S)
			Release the semaphore to signal you are done with its associated
			resource.
			
			pseudocode:
				S++
		Down(S) / P(S)
			Attempt to take the semaphore.
			
			If the semaphore is 0, wait for it to be available
			
			pseudocode:
				while(S == 0)
					block
				S--
		Removing a semaphore
	
	Semaphore code
		semget — <sys/types.h> <sys/ipc.h> <sys/sem.h>
			
			Create / get access to a semaphore.
			
			This is not the same as Up(S), the semaphore is not modified by
			semget.
			
			Returns a semaphore descriptor or -1 (errno).
			
			semget(<KEY>, <AMOUNT>, <FLAGS>)
				
				KEY
					Unique semaphore identifier (use ftok)
				
				AMOUNT
					Semaphores are actually stored as sets with possibly many
					semaphores stored together. This parameter sets the number
					of semaphores to create/get.
				
				FLAGS
					Includes permissions for the semaphore.
					
					Combine with bitwise OR.
					
					IPC_CREAT: create the semaphore
						will set value to 0.
					
					IPC_EXCL: Fail if the semaphore already exists and
						IPC_CREAT is on.
				
				example
					int semd;
					semd = semget(ftok("file/dir", 2), 1,
									0664 | IPC_CREAT)



2015-12-08 Tues
SoTD: "Time Is Running Out" — Muse
Aim: What's a semaphore? — To control resources!

Semaphore code
	semctl — <sys/types.h> <sys/ipc.h> <sys/sem.h>
		
		Control the semaphore, including:
			
			Set the semaphore value
			Remove the semaphore
			Get the current value
			Get information about the semaphore
		
		semctl(<DESCRIPTOR>, <INDEX>, <OPERATION>, <DATA>)
			
			DESCRIPTOR
				The return value of semget
			
			INDEX
				The index of the semaphore you want to control in the semaphore
				set identified by the descriptor.
				
				For a single semaphore set, 0.
			
			OPERATION
				One of the following constants (there are others as well)
				
				IPC_RMID: remove the semaphore
				
				SETVAL: Set the value
					(requires DATA)
				
				SETALL: Set the value of every semaphore in the set
					(requires DATA)
				
				GETVAL: Return the value
				
				IPC_STAT: Populate buffer with information about the semaphore.
					(requires data)
			
			DATA
				Variable for setting/storing information about the semaphore
				(datatype: union semun)
				
				union north {
					int i; // 4
					char c; // 1
					double d; // 8
				}; // size of union north is 8, not 13!
				
				union north foo;
				foo.i = 12;
				foo.d = 183.192; // overwrites all bytes
				foo.c = 'x'; // overwrites 1 byte
				printf("%c", foo.c); // prints 'x'
				printf("%f", foo.d); // prints something weird
				
				You have to declare this union in your main.c file on Linux
				machines:
				
				union semun {
					int val;
					struct semid_ds *buf;
					unsigned short *array;
					struct seminfo *__buf;
				};
					val: used to set initial value
					buf: buffer for IPC_STAT



2015-12-09 Wed
SoTD: "Bold as Love" — Jimi Hendrix
Aim: Turn down or up?

$ ipcs

Semaphore code
	semop
		
		Perform semaphore operations (like Up/Down)
		
		All operations performed via sempo are atomic!
		
		semop(<DESCRIPTOR>, <OPERATION>, <AMOUNT>)
			
			DESCRIPTOR
				You know what this is …
			
			AMOUNT
				The amount of semaphores you want to operate on in the
				semaphore set.
				
				For a single semaphore, set 1.
			
			OPERATION
				A pointer to a struct sembuf
				
				struct sembuf {
					short sem_op;
					short sem_num;
					short sem_flg;
				};
				
				sem_num
					The index of the semaphore you want to work on.
				
				sem_op
					-1: Down(S)
					1: Up(S)
						
						Any -/+ number will work, you will be requesting/
						releasing that value from the semaphore.
					
					0: Block until the semaphore reaches 0.
				
				sem_flg
					Provide further options
					
					SEM_UNDO: Allow the OS to undo the given operator. Useful
					in the event that a program exists before it could release a
					semaphore.
					
					IPC_NOWAIT: Instead of waiting for the semaphore, return
					an error
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/sem.h>
#include 


int main() {
	int key = ftok("makefile", 'a');
	int semid;
	
	semid = semget(key, 1, 0644);
	printf("Before access ...\n");
	
	struct sembuf sb;
	sb.sem_num = 0;
	sb.sem_flg = SEM_UNDO;
	sb.sem_op = -1;
	semop(semid, &sb);
	
	int i=10;
	while(i--) {
		printf("I'm in!\n");
		sleep(1);
	}
	
	sb.sem_op = 1;
	return 0;
}



2015-12-10 Thurs
2015-12-11 Fri

2015-12-14 Mon
SoTD: "Shinbone Alley" / "Hard to Exist" — Spin Doctors 
Aim: Ceci n'est pas une pipe

Pipe
	A conduit between 2 separate processes.
	
	Pipes have 2 ends, a read end and a write end.
	
	Pipes are unidirectional (a single pipe must be either read- or write-only
	in a process).
	
	Pipes act just like files.
	
	You can transfer any data you like through a pipe using read/write.
	
	Unnamed pipes have no external identification (like a descriptor or name).
	
	pipe — <unistd.h>
		Creates an unnamed pipe.
		
		Returns 0 if the pipe was created or -1 if not.
		
		Opens both ends of the pipe as files.
		
		pipe(int descriptors[2])
			descriptors
				Array that will contain the descriptors for each end of the
				pipe.

Named Pipes
	Also known as FIFO's.
	
	Same as unnamed pipes, except FIFO's have a name that can be used to
	identify them via different programs.
	
	Keep in mind that, like unnamed pipes, FIFO's are unidirectional.
	
	mkfifo
		Shell command to make a FIFO
		
		$ mkfifo <pipe name>



2015-12-15 Tues
SoTD: "Tropicalia"
Aim: Pipe

Named Pipes
	
	mkfifo — <sys/types.h> <sys/stat.h>
		
		C function to create a FIFO
		
		Returns 0 on success and -1 on failure
		
		Once created, the FIFO acts like a regular file, and we can use open,
		read, write, and close on it.
		
		mkfifo(<name>, <permissions>)
		
		FIFO's will



2015-12-16 Wed
SoTD: "Cantaloop (Flip Fantasia)" — Us3
Aim: Always remember to tip your servers

Server/Client Program Paradigms
	Handshake
		A procedure to ensure that a connection has been estbalished.
		
		Both ends of the connection must verify that they can send and receive
		data to and from each other.
		
		Basic procedure:
			1. Server creates a named pipe (well known pipe).
			2. Server waits for a connection.
			3. Client creates a private named pipe.
			4. Client connects to server and sends the private pipe name.
			5. Client waits for private pipe connection.
			6. Server receives client's message and removes the wkp.
			7. Server connects to client pipe, sending an initial
			   acknowledgement message.
			8. Client receives server's messages, removes its private pipe.



2015-12-17 Thurs
2015-12-18 Fri

2015-12-21 Mon
2015-12-22 Tues
2015-12-23 Wed
2015-12-24 Thurs
2015-12-25 Fri

2015-12-28 Mon
2015-12-29 Tues
2015-12-30 Wed
2015-12-31 Thurs


2015-01-01 Fri

2015-01-04 Mon
2015-01-05 Tues
2015-01-06 Wed
2015-01-07 Thurs
2015-01-08 Fri

2015-01-11 Mon
2015-01-12 Tues
2015-01-13 Wed
2015-01-14 Thurs
2015-01-15 Fri

2015-01-18 Mon
2015-01-19 Tues
2015-01-20 Wed
2015-01-21 Thurs
2015-01-22 Fri

2015-01-25 Mon
2015-01-26 Tues
2015-01-27 Wed
2015-01-28 Thurs
2015-01-29 Fri


2015-02-01 Mon
2015-02-02 Tues
2015-02-03 Wed
2015-02-04 Thurs
2015-02-05 Fri

2015-02-08 Mon
2015-02-09 Tues
2015-02-10 Wed
2015-02-11 Thurs
2015-02-12 Fri

2015-02-15 Mon
2015-02-16 Tues
2015-02-17 Wed
2015-02-18 Thurs
2015-02-19 Fri

2015-02-22 Mon
2015-02-23 Tues
2015-02-24 Wed
2015-02-25 Thurs
2015-02-26 Fri

2015-02-29 Mon


2015-03-01 Tues
2015-03-02 Wed
2015-03-03 Thurs
2015-03-04 Fri

2015-03-07 Mon
2015-03-08 Tues
2015-03-09 Wed
2015-03-10 Thurs
2015-03-11 Fri

2015-03-14 Mon
2015-03-15 Tues
2015-03-16 Wed 
2015-03-17 Thurs
2015-03-18 Fri

2015-03-21 Mon
2015-03-22 Tues
2015-03-23 Wed
2015-03-24 Thurs
2015-03-25 Fri

2015-03-28 Mon
2015-03-29 Tues
2015-03-30 Wed
2015-03-31 Thurs


2015-04-01
