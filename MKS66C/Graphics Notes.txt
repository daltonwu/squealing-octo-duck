netpbm
  * Raster
  * Lossless
  * Uncompressed

Format:

# header
P3
XRES YRES
MAX_COLOR_VALUE
R G B R G B R G B

All whitespace is equivalent

2016-02-05 Fr
Bresenham's Line Algorithm

Draw line from (x0, y0) -> (x1, y1)

			Octant I:

// original:
x = x0, y = y0
while(x <= x1)
	plot(x, y)
	d = f(x+1, y+1/2)
	if(d > 0)
		y += 1
	x += 1

// optimized a bit:
x = x0, y = y0
d = A + B/2
while(x <= x1)
	plot(x, y)
	if(d > 0)
		y += 1
		d += B
	x += 1
	d += A

// optimized some more:
x = x0, y = y0
d = 2A + B
while(x <= x1)
	plot(x, y)
	if(d > 0)
		y += 1
		d += 2B
	x += 1
	d += 2A

			Octant II:

x = x0, y = y0
A = y1 - y0, B = -(x1 - x0)
d = A + 2B
while(y <= y1)
	plot(x, y)
	if(d < 0)
		x += 1
		d += 2A
	y += 1
	A += 2B



16-02-22 Mo
Using Matrices
Point Matrix



16-02-23 Tu
Matrix Math Review
	Scalar multiplication
		
	Matrix multiplication
		|a b c| |1 4|   |(a + 2b + 3c) (4a + 5b + 6c)|
		|d e f| |2 5| = |(d + 2e + 3f) (4d + 5e + 6f)|
		|g h i| |3 6|   |(g + 2h + 3i) (4g + 5h + 6i)|

	Multiplicative Identity	Matrix
		* Square matrix
		* Diagonal values are 1; rest are 0



16-02-24 We
Transformation Matrices

Scaling
	(x, y, z) -----------> (ax, by, cz)
	           S(a, b, c)
	
	|a 0 0 0| |x|   |ax|
	|0 b 0 0| |y|   |by|
	|0 0 c 0| |z| = |cz|
	|0 0 0 1| |1|   |1 |

Translating
	(x, y, z) -----------> (x+a, y+b, c+z)
	           T(a, b, c)
	
	|1 0 0 a| |x|   |x+a|
	|0 1 0 b| |y|   |y+b|
	|0 0 1 c| |z| = |z+c|
	|0 0 0 1| |1|   |1  |

Rotating
	(x, y, z) -------> (xcosθ-ysinθ, xsinθ+ycosθ, z)
	           R_z, θ
	
	x_r = rcos(ϕ + θ) = xcosθ - ysinθ
	y_r = rsin(ϕ + θ) = ycosθ + xsinθ
	
	|cosθ -sinθ 0 0|
	|sinθ  cosθ 0 0|
	|0     0    1 0|
	|0     0    0 1|
	
	(x, y, z) -------> (x, ycosθ-zsinθ, ysinθ+zcosθ)
	           R_x, θ
	
	|1  0     0    0|
	|0  cosθ -sinθ 0|
	|0  sinθ  cosθ 0|
	|0  0     0    1|
	
	(x, y, z) -------> (xcosθ-zsinθ, y, xsinθ+zcosθ)
	           R_y, θ
	
	|cosθ 0 -sinθ 0|
	|0    1  0    0|
	|sinθ 0  cosθ 0|
	|0    0  0    1|



16-02-25 Th
Applying Transformations

E_0    edge matrix    (4 × n)
T      translate      (4 × 4)
S      scale          (4 × 4)
R      rotate         (4 × 4)

T × E_0 = E_1
S × E_1 = E_2
R × E_2 = E_3

E_3 = (R × S × T) × E_1



16-03-07 Mo
Parametric Equations

x = f(t)
y = g(t)
t: 0 -> 1

drawing sin curve—number of lines matters (like poly count)
piecewise functions

Hermite curve inputs:
	* Endpoints P0, P1
	* Rates of change at each endpoint, R0, R1

f(t) = at^3 + bt^2 + ct + d
f'(t) = 3at^2 + 2bt + c

t: 0 -> 1

|0 0 0 1| |a|   |d            |   |P0|
|1 1 1 1| |b|   |a + b + c + d|   |P1|
|0 0 1 0| |c| = |c            | = |R0|
|3 2 1 0| |d|   |3a + 2b + c  |   |R1|
    H        G           C

| 2 -2  1  1|
|-3  3 -2 -1|
| 0  0  1  0|
| 1  0  0  0|
  H inverse



16-03-09
Bezier Curve

Inputs
	P0, P3 (endpoints)
	P1, P2 (influence points)

Linear Bezier curve
	P0, P1 (endpoints)
	
	P(t) = (1-t)P0 + tP1

Quadratic
	P0, P2 (endpoints)
	P1 (influence point)
	
	R(t) = (1-t)R0 + tR1
	
	R0(t) = (1-t)P0 + tP1
	R1(t) = (1-t)P0 + tP2
	
	R(t) = (1-t)**2 * P0 + 2t*(1-t) * P1 + t**2 * P2

Cubic
	P0, P1, P2, P3 -> at^3 + bt^2 + ct + d
	
	R(t) = (1-t) * Q0 + t * Q1
	     = (1-t)**3 * P0 + 3*t*(1-t)**2 * P1 + 3*t**2*(1-t) * P2 + t**3 * P3
	     = (-P0 + 3P1 - 3P2 + P3)t^3 + (3P0 - 6P1 + 3P2)t^2 + (-3P0 + 3P1)t + P0
	
	|-1  3 -3 1| |P0|   |a|   | -P0 + 3P1 - 3P2 + P3|
	| 3 -6  3 0| |P1|   |b|   | 3P0 - 6P1 + 3P2     |
	|-3  3  0 0| |P2| = |c| = |-3P0 + 3P1           |
	| 1  0  0 0| |P3|   |d|   |  P0                 |
	
	at^3 + bt^2 + ct + d
	2 exponentiation, 3 multiplication, 3 addition
	
	t(t(at + b) + c) + d
	3 multiplication, 3 addition



16-03-14
psuedocode:

x0 = shape-x(0)
y0 = shape-y(0)

for t: .1 -> 1
	x = shape_x(t)
	y = shape-y(t)
	
	add_edge(x0, y0, x, y, edges)
	
	x0 = x
	y0 = y



16-03-21
3D Shapes

Box, sphere, torus, Bezier/Hermite surfaces*

Box
Inputs: width, height, depth
        (x, y, z)
        upper-left-front

Sphere

θ: angle of circle creation
ϕ: angle of circle rotation

if θ: 0 -> 2pi
    ϕ: 0 -> pi

if θ: 0 -> pi
    ϕ: 0 -> 2pi


|1 0     0     0||rcosθ|   |rcosθ    |
|0 cosϕ -sinϕ  0||rsinθ|   |rsinθcosϕ|
|0 sinϕ  cosϕ  0||0    | = |rsinθsinϕ|
|0 0     0     1||1    |   |1        |

for p: 0 -> 1
    for t: 0 -> 1
        x = rcos(pi*t)
        y = rsin(pi*t)cos(2pi*p)
        z = rsin(pi*t)sin(2pi*p)

Torus

|1 0     0    0||rcosθ    |   |rcosθ          |
|0 cosϕ -sinϕ 0||rsinθ + R|   |cosϕ(rsinθ + R)|
|0 sinϕ  cosϕ 0||0        | = |sinϕ(rsinθ + R)|
|0 0     0    1||1        |   |1              |



Polygon Meshes

Bob Dylan — "Just Like Tom Thumb's Blues"

box: 12 triangles, 2 per face
counterclockwise

   p4 --- p5
  /|     /|
 / |    / |
p0 --- p1 p6
|      | /
|      |/
p3 --- p2

// front
p0, p3, p2
p0, p2, p1

// back
p5, p7, p4
p5, p6, p7

sphere

i, i + n + 1, i + n
i, i + 1, i + n + 1



16-04-05
Backface Culling
* Not render any backwards-facing surfaces
* The surface normal N is a vector orthogonal to a plane
* We compare N to the view vector / camera (?)  V

Algorithm
1. Calculate N
    * Cross product of two vectors that share an endpoint and go in different
      directions
    * A = <x1 - x0, y1 - y0, z1 - z0>
    * B = <x2 - x0, y2 - y0, z2 - z0>
    * A × B = <AyBz - AzBy, AzBx - AxBz, AxBy - AyBx>
2. Find angle between N and V
3. If the angle is between 90° and 270°, draw the surface

